## 一、   概述

系统上线之后，一旦发生异常，第一件事就是要弄清楚当时发生了什么，用户当时做了什么操作，环境有无影响，数据有什么变化，是不是反复发生等，然后再进一步的确定大致是哪个方面的问题。这时，日志就给我们提供了第一手的资料。好的日志规范不仅有助于加快定位问题的原因，还可以基于日志预防问题的发生。

## 二、   范围

适用于法大大应用系统开发编码过程。

## 三、   日志规范

日志格式

%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level ${PID:- } ${APP_ID} ${HOSTNAME} [%thread] %logger{36} ^_^ %msg%n

 

其中msg= "{}" + SEPARATOR + "{}-{}" + SEPARATOR + "{}"; //^_^traceId^_^monitor-operate^_^message

traceId的传递：线程内通过slf4j的MDC存储

​               跨线程通过方法参数传递

​              跨进程（http协议）通过请求头自定义fdd_trace_id（key-value）传递

### 3.1 业务日志规范

#### 1.【强制】应用中不可直接使用日志库（Log4j、Logback）中的API，而应使用日志框架SLF4J中的API。

使用门面模式的日志框架，有利于维护各个类的日志处理方式统一。

#### 2.【推荐】对不确定会否输出的日志，采用占位符或条件判断

//WRONG

logger.debug("Processing trade with id: " + id + " symbol: " + symbol);

如果日志级别是info，上述日志不会打印，但是会执行1)字符串拼接操作，2)如果symbol是对象，还会执行toString()方法，浪费了系统资源，最终日志却没有打印。

//RIGHT

logger.debug("Processing trade with id: {} symbol : {} ", id, symbol);

但如果symbol.getMessage()本身是个消耗较大的动作，占位符在此时并没有帮助，须要改为条件判断方式来完全避免它的执行。

//WRONG

logger.debug("Processing trade with id: {} symbol : {} ", id, symbol.getMessage());

 

//RIGHT

if (logger.isDebugEnabled()) {

 logger.debug("Processing trade with id: " + id + " symbol: " + symbol.getMessage());

}

#### 3.【推荐】对确定输出，而且频繁输出的日志，采用直接拼装字符串的方式

 如果这是一条WARN，ERROR级别的日志，或者确定输出的INFO级别的业务日志，直接字符串拼接，比使用占位符替换，更加高效。Slf4j的占位符并没有魔术，每次输出日志都要进行占位符的查找，字符串的切割与重新拼接。

//RIGHT

[logger.info](http://logger.info/)("I am a business log with id: " + id + " symbol: " + symbol);

 

//RIGHT

logger.warn("Processing trade with id: " + id + " symbol: " + symbol);

#### 4.**【强制】禁止使用性能很低的System.out()打印日志信息**

同理也禁止e.printStackTrace();

#### 5.**【推荐】谨慎地记录日志，避免大量输出无效日志，信息不全的日志**

大量地输出无效日志，不利于系统性能，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？

#### 6.**【强制】打印日志注意敏感数据的脱敏。**

**示例：密码，身份证号码等**

#### 7.**【推荐】图片的base64编码在日志中隐藏（图片不写入日志或以debug级别在调试时输出）**

#### 8.**【强制】同一个请求的所有日志使用统一定位关键字（包括异常日志）**

#### 9.**【推荐】一条日志打印在一行内，不能换行打印**

 

### 3.2 异常日志规范

#### 1.【强制】创建异常的消耗大，只用在真正异常的场景

 构造异常时，需要获得整个调用栈，有一定消耗。

不要用来做流程控制，条件控制，因为异常的处理效率比条件判断低。

发生概率较高的条件，应该先进行检查规避，比如：IndexOutOfBoundsException，NullPointerException等，所以如果代码里捕获这些异常通常是个坏味道。

//WRONG

try {

 return obj.method();

} catch (NullPointerException e) {

 return false;

}

//RIGHT

if (obj == null) {

 return false;

}   

#### 2.**【推荐】异常日志应包含排查问题的足够信息**

#### 3.**【强制】异常处理不能吞掉原异常，要么在日志打印，要么在重新抛出的异常里包含原异常**

#### 4.【强制】如果不想处理异常，可以不进行捕获。但最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容

## 四、     日志管理配置

### 4.1 目标

日志文件能够按照自然时间每天新增一个日志文件，并保留最近一段时间内的日志，超出配置时间范围的日志需要自动删除或者压缩后迁移到其他地方 

### 4.2 Log4j

Log4j作为常用的日志生成工具，其清除日志的策略却十分有限。只有在RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）中可以通过设置MaxFileSize和maxBackupIndex属性来指定要保留的日志文件大小以及个数，从而实现自动清除。

可是Log4j中的DailyRollingFileAppender（每天产生一个日志文件）这个类却不带属性maxBackupIndex,maxFileSize等，所以无法通过直接配置实现。

要实现目标需要我们自己重写DailyRollingFileAppender，增加maxBackupIndex属性（考虑到实际使用场景，建议仅支持按天滚动）

### 4.3 Logback

Logback 是一个 Java 领域的日志框架，目前 Logback 的使用很广泛。它被认为是 Log4J 的继承人，Logback 相对于 Log4J 有更多的优点，天然支持自动删除日志归档，自动压缩日志成为归档文件。

## 五、日志上报

日志管理的用途可以分为2个方面。一个是监控，一个是问题回溯。

所有请求，从进入controller到响应输出，日志要标记出开始和结束，并在结束的日志中输出结果（成功，失败，异常）。

一般日志按照用户需求设置级别，比如设置为error。此部分日志跟随系统日志一起直接上报到云端

另外设置一个Appender输出到消息队列，自研一个日志消费系统（过滤 ，监控，告警，上报）消费消息。根据trace_id划分存储到缓存中。如果异常或者失败则把相同trace_id的日志上报到到云端，否则丢弃。

## 六、日志级别

### 6.1日志级别定义

Log4j中定义了ALL，TRACE，DEBUG，INFO，WARN，ERROR，FATAL，OFF八种级别

Logback中定义了ALL，TRACE，DEBUG，INFO，WARN，ERROR，OFF七种级别

他们的级别都是从低到高，考虑到logback功能更强大，应用也很广泛，所以这里以logback为标准，下面是每种级别的官方定义：

ALL：用于打开所有日志记录。

TRACE：指定非常低重要性的信息事件。

DEBUG：指定较低重要性的信息事件。

INFO：指定信息性消息，突出显示应用程序的整体进度。

WARN：指定潜在的有害情况。

ERROR：指定错误事件，这些错误事件对应用程序可能是致命的，也可能不是致命的。

OFF：用于关闭日志记录。

### 6.2内部日志级别规范

虽然日志级别有7种，但我们常用的日志级别只有：DEBUG，INFO，WARN，ERROR四种，其他级别不建议使用。下面我们来详细说明这四种级别的用法

#### DEBUG

看名字可以知道debug常用来表示开发人员对代码的调试过程。这个级别在系统运行期间一般都是不输出的。所以可以较多的使用，并且输出越详细越好，比如进入方法后输出所有的参数等。为了减少对系统性能的影响，所有日志必须加上条件判断

#### INFO

系统运行期间，这种级别一般都是主要输出日志。我们都知道平时接触日志最多的可能就是运维人员，他们对业务逻辑并不熟悉，所以对于具体的参数信息并不会过多的关注，他们更关心的是系统是否运行正常，业务是否执行正常。说得更直观一点就是业务执行的结果是成功还是失败。所以info级别的日志对最终用户是友好的，不了解具体业务的人也能看得懂。

#### WARN

翻译过来是“警告”，字面意思是有问题但是不影响业务，这种问题可以理解为业务问题，开发时就可以提前预见，并在业务上有处理预案。比如签署时SaaS API请求底层原子服务超时，此时可以输出warn告警，然后发起重试机制。另外对于自定义的业务异常也可以使用warn输出（不能打印异常堆栈信息）

#### ERROR

这种级别的输出一定是系统出现问题，并且该问题已经影响业务流程无法执行下去。这种问题可以理解为系统问题。比如从缓存获取数据，发现没有命中，然后从数据库获取数据，但连接数据库失败。此时可以输出error（此时需要打印异常堆栈信息）

### 6.3总结

总的来说debug用于开发调试以及排查问题时使用。info是主要输出级别，用于记录业务执行状态，方便监控。warn的主要目的是辅助info的输出，记录业务执行的特殊状态，方便监控。error属于比较严重的问题,输出的日志一般用于问题排查和监控告警（需要快速响应）。

Debug和info还是比较好区分的，比较难区分的点是info和warn、以及warn和error。

info和warn都是记录业务执行状态，前者更偏向正常状态的业务执行流程，后者更偏向非正常状态的业务执行流程。

warn和error都代表异常情况，但是前者对业务几乎没有影响或者从业务角度来说可以忽略。后者对业务影响较大，甚至业务不能执行下去。

## 七、日志埋点规范

1、请求入参信息需要详细输出-INFO

*Controller**的方法的第一行输出请求的所有参数（文件流输出大小，**base64**输出长度），响应之前输出**returnDTO**（**code,msg**）*

2、通过网络远程执行的逻辑（http,rpc等网络协议，包括操作oss），执行前后需要输出详细信息-INFO

*输出请求的所有参数（**base64**除外），接收到响应之后输出**returnDTO**（**code,msg**）*

*返回正常的**code(**成功或失败**)**以**info**级别输出，其他异常情况（超时，**http**非法状态）以**error**级别输出*

*如果涉及到文件传输，需要输出文件的大小*

3、try-catch代码块中catch部分需要输出详细信息（可以不输出异常堆栈堆栈信息）-ERROR

*自定义异常直接向上抛异常，系统异常：业务继续处理的情况在当前位置输出日志并继续处理，业务不处理的情况下直接向上抛异常；*

4、响应出参信息需要详细输出-INFO

5、其他情况参考[六、日志级别](file:///D:/【0】规范/1-开放平台部/附件/法大大日志编码规范V3.docx#_六、日志级别)

6、敏感信息脱敏

*中国大陆个人手机号码显示为**:158****9119**，显示前三位、后四位，隐藏中间**4**位。* *
**中国大陆个人身份证号码显示为**:210002*********359**，显示前六位、后三位，隐藏中间**9**位。前缀仅显示第一个字母，前缀其他隐藏，用星号代替，**@**及后面的地址显示。**
**银行卡号**: 622260*********1234**，显示前六位、后四位，中间隐藏为星号。**
**密码**:**********，隐藏全部字符。*

7、数据库，MQ，缓存等中间件操作日志以debug级别输出（详细信息，至少包含请求参数信息）

*请求前以及接受响应后都需要输出日志*

## 八、日志脱敏

### Log4j

待更新...

### Logback

可以通过自定义类继承MessageConverter的方式实现，代码完成后需要配置如下：

<conversionRule conversionWord="msg" converterClass="自定义类 "> </conversionRule>

待更新...

## 九、日志性能

异步缓冲策略

待更新...